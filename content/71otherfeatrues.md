## 7. 其它特性

### 7.1. IDs
需要一个ID代理或者发行服务，无论何时CellApp创建一个新的entity，都需要一个唯一的entity ID。目前由CellAppMgr提供这个功能。  

#### 7.1.1. ID分配
CellAppMgr目前作为一个ID中心代理负责分配ID。它处理对ID段的请求，回收没有被使用的ID。  
如果CellAppMgr在崩溃后被Reviver重启，它将通过查询Cell中的最高ID值来恢复它的状态。ID序列将从最高ID值重新开始，加1.这个过程中，因为失败的事件，一小撮ID可能被浪费掉。  
多余未用的ID被存储在特殊的表~~bigworldNewID，bigworldUsedIDs~~。更详细的说明，请看`<服务端编程指南>`MySQL数据库模式的非entitybiao表。

### 7.2. 进程间通信 (Mercury)
#### 7.2.1. 概览
BigWorld的Mercuty是用于客户端和服务端之间、所有服务端组件之间通信的网络层。它基于UDP，同时支持可靠和不可靠通信。而KBEngine的客户端和服务端之间通信是基于TCP的。

#### 7.2.2. Nub
Nub是Mercury的核心。它负责发送和接收数据包，发送时间消息，和通用的socket通知。  
BigWorld所有的通信使用UDP协议，因此对所有的连接使用一个单一的的socket，这远比对每个连接使用一个socket高效，在大量的socket上调用select是很缓慢的。  
Nub通常控制应用程序的事件循环，因此它也提供一个时间队列和用户套接字通知。时间队列用于周期性的调用回调函数，或者在时间结束后调用一个单一的回调。当用户套接字准备好读取数据时，能用于监听和调用回调函数。  

#### 7.2.3. 消息（Messages）
消息（Message）是通信的基本单元。它包括：  

* 消息类型 .... 1byte.
* 消息大小 .... 0-4 bytes.
* 消息数据 .... 可变大小。

固定长度消息不需要消息大小。消息数据是一个能被客户端和服务端解释的简单字节流（stream of bytes）。给大多数数据类型提供了流算子，让消息编组更简单。


#### 7.2.4. 请求（Requests）
一个请求是一个期望应答的消息。可以发出一个请求给客户端，并在没有阻塞进程运行的情况下接收一个和它相关联的回复。本质上，Mercury将分配一个唯一的请求ID，用于和请求的回复关联。当请求发出，一个回复的处理也会被创建。它也处理超时，如果没有在定义好的时间内收到应答会调用一个超时回调。  

#### 7.2.5. Bundles
Bundle是作为一个单元被发送和接收的消息的集合。把多个消息组合起成一个单一的数据包减少了UDP的包头开销（overhead）。如果一个bundle超过了包的最大尺寸，它将被分割成多个包，在它被接收到时重新装配。  
每个在bundle中的消息包都可选额外数据，包括队列数量，请求ID和确认ID。

#### 7.2.6. 通道（Channels）
通道用于在两个Nub间提供稳定的通信。一个通道可能有不同的特征，取决于它是一个 客户端／服务端 通道或者是 服务端／服务端 通道。  
以下的表描述了每个通道的特征：

channel | Latency | Bandwidth | Loss
------- | ------- | --------- | -----
Client/Server | High | Low | High
Server/Server | Low | High | Low

一个通道的特性可以在创建时指定，这样可以正确的选择它的可靠算法。 