## 7. 其它特性

### 7.1. IDs
需要一个ID代理或者发行服务，无论何时CellApp创建一个新的entity，都需要一个唯一的entity ID。目前由CellAppMgr提供这个功能。  

#### 7.1.1. ID分配
CellAppMgr目前作为一个ID中心代理负责分配ID。它处理对ID段的请求，回收没有被使用的ID。  
如果CellAppMgr在崩溃后被Reviver重启，它将通过查询Cell中的最高ID值来恢复它的状态。ID序列将从最高ID值重新开始，加1.这个过程中，因为失败的事件，一小撮ID可能被浪费掉。  
多余未用的ID被存储在特殊的表~~bigworldNewID，bigworldUsedIDs~~。更详细的说明，请看`<服务端编程指南>`MySQL数据库模式的非entity表。

### 7.2. 进程间通信 (Mercury)
#### 7.2.1. 概览
BigWorld的Mercuty是用于客户端和服务端之间、所有服务端组件之间通信的网络层。它基于UDP，同时支持可靠和不可靠通信。而KBEngine的客户端和服务端之间通信是基于TCP的。

#### 7.2.2. Nub
Nub是Mercury的核心。它负责发送和接收数据包，发送时间消息，和通用的socket通知。  
BigWorld所有的通信使用UDP协议，因此对所有的连接使用一个单一的的socket，这远比对每个连接使用一个socket高效，在大量的socket上调用select是很缓慢的。  
Nub通常控制应用程序的事件循环，因此它也提供一个时间队列和用户套接字通知。时间队列用于周期性的调用回调函数，或者在时间结束后调用一个单一的回调。当用户套接字准备好读取数据时，能用于监听和调用回调函数。  

#### 7.2.3. 消息（Messages）
消息（Message）是通信的基本单元。它包括：  

* 消息类型 .... 1byte.
* 消息大小 .... 0-4 bytes.
* 消息数据 .... 可变大小。

固定长度消息不需要消息大小。消息数据是一个能被客户端和服务端解释的简单字节流（stream of bytes）。给大多数数据类型提供了流算子，让消息编组更简单。


#### 7.2.4. 请求（Requests）
一个请求是一个期望应答的消息。可以发出一个请求给客户端，并在没有阻塞进程运行的情况下接收一个和它相关联的回复。本质上，Mercury将分配一个唯一的请求ID，用于和请求的回复关联。当请求发出，一个回复的处理也会被创建。它也处理超时，如果没有在定义好的时间内收到应答会调用一个超时回调。  

#### 7.2.5. Bundles
Bundle是作为一个单元被发送和接收的消息的集合。把多个消息组合起成一个单一的数据包减少了UDP的包头开销（overhead）。如果一个bundle超过了包的最大尺寸，它将被分割成多个包，在它被接收到时重新装配。  
每个在bundle中的消息包都可选额外数据，包括队列数量，请求ID和确认ID。

#### 7.2.6. 通道（Channels）
通道用于在两个Nub间提供稳定的通信。一个通道可能有不同的特征，取决于它是一个 client/server 通道或者是 server/server 通道。  
以下的表描述了每个通道的特征：

channel | Latency | Bandwidth | Loss
------- | ------- | --------- | -----
Client/Server | High | Low | High
Server/Server | Low | High | Low

**以下client/server的策略是基于BigWorld，KBEngine使用的是TCP协议。**
一个通道的特性可以在创建时指定，这样可以正确的选择它的可靠算法。  
如果数据包中的消息被标记为可靠，那么整个数据包也会被视为可靠。发送者会给它分配一个队列数字并存储到滑动窗口。一旦接收者收到数据包会马上确认，会放置一个ACK到下一个发出的数据包。通道会被假定为定期的双向通信(10Hz for client/server, 50Hz for server/server)。  
如果接收到一个乱序的ACK包，它会假定前序包丢失了，会重新发送。在低延迟的情况下，存在一个阈值，在一个确定的时间内哪些包在它们第一次发送后将不会被重新发送。  
低带宽(low‐bandwidth)的连接中(client/server)，所有不可靠的消息在重新发送之前都会被从数据包剥离，为了节省带宽，如果可能，这个数据包会携带下一个准备发出的数据包。  

#### 7.2.7. Interfaces
从Nub接收的消息会被单个接口处理。因为消息类型是单一的字节，一个接口的限制能达到256个消息（实际上会稍微小一点，因为Mercury保留了一些内部使用信息）。  
接口通常被使用宏定义在interface_minder.hpp。这样的设计是为了隐藏消息解码的调用细节和调度(dispatching)。对于简单的固定长度消息，结构包含了消息参数，结果是一个对象的方法被调用。对于更复杂的可变长度消息，参须必须手动解析字节流，结果是一个stream对象和方法被调用（可参看u3d客户端插件对于这2种消息的处理）。  
接口也定义消息是否是可变的还是固定长度的。对于固定长度消息，不需要发送长度数据，因为接收者知道有多少字节。

### 7.3. 容错和灾难恢复
服务端的每个组件都有容错设计。任何服务端进程或者机器都可能异常死亡，服务端应当在影响不大的继续运行。服务端组件的说明有关于它们处理容错的细节。  
引擎同样提供了秒级的容错级别，即灾难恢复。服务端的状态能周期性的写入数据库，在整个服务端出现故障（failure）的事件中，服务端能够使用这些信息重新启动。

### 7.4. 文件打包
Packed files are read‐only and are usually unsuitable for use during development. Most of the tools (both client and server) will not work with packed files due to its read‐only nature.
XML文件因为它的灵活性和易用性而被引擎使用，XML文件也被广泛认为很臃肿，当在一个电脑游戏中使用，很容易被最终用户修改。文件打包是把XML文件转换为压缩的二进制格式。当需要一个XML文件时，客户端和所有的服务端组件都能加载被打包文件。使用打包文件取代XML文件提高了性能，这在一定程度上的混淆也可以阻止一般用户修改文件内容。  
打包文件是只读的并不适用于开发中。因为它的只读属性，大多数工具（无论是在客户端还是服务端）无法使用打包文件。

