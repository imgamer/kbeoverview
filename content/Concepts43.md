### 4.3 发布者/订阅者
  许多系统中的对象都是数据的订阅者。~~如real avatar（publicsher）和它的ghost们（subscribers）是明确的 发布者/订阅者 关系。~~广义的讲任何对象都可以是一个entity的订阅者，对于base也是一样。  
  例如，一个门entity订阅到一个按钮entity的base，当按钮改变状态，门也会适当响应。  

  订阅能够被实现为各种不同类型。  
  例如，为了让玩家可以看到游戏世界的其它部分，就有了相机和屏幕（视野）的概念。相机就像是一个游戏角色，当一个客户端可以看到游戏屏幕（具有视野）时，相当于根据屏幕尺寸用不同的服务（或者带宽）质量需求订阅了相机。另一个例子是上面所说的门的实现，只按钮按下有反应，而不会对按钮旋转或者移动有反应。
  更详细的讨论参见观察者设计模式。

### 4.4 延迟
  游戏设计师需要用尽可能多的延迟隐藏技巧对玩家隐藏延时。延迟主要有二种来源：  

  1. 内部延迟：所有在客户端间的传输都要经过服务端，这就必须在互联网上传输二次。
  2. 服务端延迟：这是服务端接收数据的时间，处理数据并发回客户端。在一个有大量玩家的MMOG环境，带宽是一个宝贵的资源，所以不是所有的信息都可以立即被发送。引擎使用了优先队列来处理这个问题。

  优先队列能够被调整，以减少服务器上造成的关键信息延迟，但这不会影响网络延迟。  
  延迟同样在客户端被引入。这产生在开发者允许的接收数据和发送给服务端之间，或者接收数据和做数据表现之间。

### 4.5 Spaces和cells
  游戏世界是由很多空间(spaces)组成的。每个空间是一个连续的欧氏区域，跨越单一的坐标系统。  
  空间可能会一直存在，或者动态的创建出来以便允许一组或一个玩家在其间冒险并和其他玩家隔离开来。可能会有很多指定的空间实例同时并独立的使用一个几何空间场景。  
  ![图片示例]  
  空间是一个被游戏脚本处理的逻辑概念。  
  Cell更像是一个物理级别的概念，它们把庞大的游戏空间几何分块，目的是为了跨越多个CellApp来进行动态负载平衡。动态负载平衡是引擎未来的目标，目前还未实现，当前可以理解为一个space只有一个cell。  
  ![图片示例]  
  而对于一个小空间，一个单独的cell就能够覆盖它。space作为一个逻辑概念，并不应该有大小在bigworld中，cell的划分和边界的动态调整取决于entity密度。  
  ![图片示例]  
